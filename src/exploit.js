const { SerialPort } = require('serialport')
const https = require('https')

const configs = require('./devices')

const {talk, sleep, confirm, waitDevice, getDevice} = require('./utils')

const chalk = require('chalk')

let portPath = ""
const baudRate = 19200
let port
let device

const retries = {mempatch:0, install:0}

async function identifyDevice(path) {
    portPath = path
    port = new SerialPort({path: portPath, baudRate}) 
    return talk(port, {
        receiverType: 0,
        cmdSet: 0, 
        cmdId: 1
    }, true).then((result) => {
        //console.info("identify response", Buffer.from(result.data).toString('hex'))
        const responseText = String.fromCharCode.apply(null, result.data)
        //console.log(responseText);
        device = responseText.match(/(WM150|LT150|GL150|GP150|gl170)/g)[0]
        console.log("found", device)
        if(!configs[device]) {
            throw "unknown device or in wrong mode"
        }
    })
}

async function ota() {
    console.log("asking nicely")
    const config = configs[device].ota;
    config.data = config.request;
    return talk(port, config, true).then((result) => {
        //console.info("result", Buffer.from(result.data).toString('hex'))
       
       //determine challange payload offset
        var offset = 0
        //old devices are at 6
        if(result.data[6] === 0x0e) {
            offset = 1
        }
        //newer devices are et 5
        else if(result.data[5] === 0x0e) {
            offset = 0
        }
        else {
            console.info("result", Buffer.from(result.data).toString('hex'))
            throw "no such show"
        }

        //console.log("got ota challange, firing request", 'https://drone-hacks.com/get/otawm150/7645436e-a439-11eb-bcbc-0242ac130002/'+Buffer.from(result.data).toString('base64url'))
        return new Promise((resolve, reject) => {
            https.get('https://drone-hacks.com/get/otawm150/7645436e-a439-11eb-bcbc-0242ac130002/'+Buffer.from(result.data).toString('base64url'), (res) => {
                if(res.statusCode !== 200) {
                    throw "the signing server is having a bad day, please try again later or contact the team."
                }
                let data = [];
              
                res.on('data', chunk => {
                  data.push(chunk);
                });
                res.on('end', () => {
                    var res = Buffer.concat(data).toString()
                    if(res === "nope!") {
                        throw "your serial "+Buffer.from(result.data.slice(offset+6, offset+6+14)).toString()+" was not recognized by the server. contact the fpv.wtf team."
                    }
                    //console.log("response from server: ", Buffer.from(res, "base64url").toString("hex"))
                    resolve(Buffer.from(res, "base64url").slice(0, 106))
                });
            }).on('error', (e) => {
                //console.log("error")
                throw "error: "+e.toString()+"\ncouldn't contact signing server, it may be blocked by your ISP. make sure you are online, try again later or contact the fpv.wtf team. "
            });
        }).then((result) => {
            if(!result) {
                process.exit(1);
            }
            config.data = result
            return talk(port, config, true).then((result) => {

                if(result.data[0] !== 0) {
                    console.info("result", Buffer.from(result.data).toString('hex'))
                    throw "firmware too new, you need to use butter to downgrade: https://github.com/fpv-wtf/butter#usage"
                }
                else {
                    if(config.restart) {
                        return restart()
                    }
                    else {
                        //possible racecond on v2s?
                        return sleep(3000)
                    }
                }
            })
        })
        
    })
}

async function restart(wait = true) {
    //console.log("asking device to restart")
   
    return talk(port, configs[device].restart, false).then((result)=>{
        //LT150 doesn't respond to restart, goes for it right away
        /*if(result.data[0] !== 0) {
            console.info("result", result.data.toString('hex'))
            throw "unable to reboot"
        }*/
        if(wait) {
            console.log("waiting for device to reboot")
            return waitDevice(10000, portPath).then(()=>{
                port = new SerialPort({path: portPath, baudRate}) 
            })

        }
    })
}

async function patch() {
    console.log("waving wand")
    const config=configs[device].patch
    config.data = makeShellPayload(`busybox devmem ${config.address} 16 ${config.value}`)
    return talk(port, config, true).then(async (result)=>{
        if(result.data[0] === 0) {
            return true 
        }
        /*else if(retries.mempatch > 5) {
            throw "harry, i'm sorry, you're not a wizard"
        }*/
        retries.mempatch++
        console.info("result", Buffer.from(result.data).toString('hex'))
        console.log("wand fizzled, need to retry")
        console.log("dont worry, this is normal")
        console.log(chalk.bgMagenta.bold("please power cycle your device now"))
        while(await getDevice(portPath, true)) {
            await sleep(100)
        }
        console.log("waiting for device to reboot")
        return waitDevice(10000, portPath).then(()=>{
            port = new SerialPort({path: portPath, baudRate}) 
        })
        .then(ota)
        .then(patch)
    })
}

async function doShell(path, command) {
    console.log("executing "+command)
    return identifyDevice(path).then(()=>{
        return shell(command)
    }) 
    
}
async function doReboot(path) {
    console.log("rebooting")
    return identifyDevice(path).then(()=>{
        return restart(false)
    }).then(()=>{
        process.exit(0)
    });
    
}
function shell(command) {
    const config=configs[device].patch
    config.data = makeShellPayload(command)
    return talk(port, config, true).then((result)=>{
        if(result.data[0] === 0) {
            console.log("success")
            return true 
        }
        else {
            throw "harry, i'm sorry, you're not a wizard"
        }
    })
}

async function unlockDebug() {
    console.log("asking again, this time with some gusto")
    const config = configs[device].debug
    config.data = Buffer.from("00000E00AF5C5F2800295F2FAF4849444A490000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF000000FEFFFFFF00000000880AEE0E01D4E85374710961DECE84176BF1F91800000000000000000000000000000000000000000000000000000000", "hex")
    return talk(port, config, false) 
    .then((result) => {
        if(result && result[0] !== 0) {
            console.log("response", Buffer.from(result.data).toString('hex'))
            throw "nope, sorry"
        }
        //console.info(result)
        try {
            port.close()
        }
        catch(e) {

        }        
        console.log("waiting for device to reboot")
        return waitDevice(10000, portPath).then(()=>{
            port = new SerialPort({path: portPath, baudRate}) 
        })
    })
}

async function installStartup() {
    const config=configs[device].install
    if(config.skip) {
        return true
    }
    console.log("leaving something to remember me by")
    var remount = "";
    if(config.engineering) {
        remount="mount -o bind,ro /blackbox/cmdline /proc/cmdline || true\n"
    }
    config.data = makeShellPayload(`cat /proc/cmdline | busybox sed -e 's/state=production/state=engineering/g' -e 's/verity=1/verity=0/g' -e 's/debug=0/debug=1/g' > /blackbox/cmdline
C="busybox devmem ${config.selinuxdisable} 32 0
mount -o rw,remount /system"
eval "$C"
cd /system/bin
T=setup_usb_serial.sh
sed -i '/#margerine/,/#\\/margerine/d' $T
echo "#margerine\n$C\n${remount}#/margerine" >> $T
chgrp shell $T
chcon u:object_r:dji_service_exec:s0 $T
restorecon $T
reboot`)
    return talk(port, config, true).then((result) => {
        if(result.data[0] === 0) {
            console.log("waiting for device to reboot!")
            return waitDevice(10000, portPath)
        }
        else if(retries.install > 5) {
            throw "couldn't patch startup, sorry"
        }
        retries.install++
        console.log("couldn't patch startup, retrying")
        return installStartup()
    })
}

async function unlock(path) { 
    console.log("hang in there, this is going to take a few minutes\n")
    return identifyDevice(path)
    .then(restart)
    .then(ota)
    .then(patch)
    .then(unlockDebug)
    .then(restart)
    .then(installStartup)
    .catch((error)=>{
        try {
            port.close()
            console.log(error)
            process.exit(1)
        }
        catch(e) {

        }
        //console.log(error)
        throw error
    })
}

async function lock(path) { 
    return identifyDevice(path)
    .then(() => {
        const config = configs[device].install
        config.data = makeShellPayload(`cd /system/bin
        T=setup_usb_serial.sh
        sed -i '/#margerine/,/#\\/margerine/d' $T
        chgrp shell $T
        chcon u:object_r:dji_service_exec:s0 $T
        restorecon $T
        reboot`)
        return talk(port, config, true)
        .then((result) => {
            if(result.data[0] === 0) {
                return true
            }
            //console.info(Buffer.from(result.data).toString('hex'))

            throw "couldn't do the 1st thing, sorry"
        })
    }).catch((error)=>{
        try {
            port.close()
        }
        catch(e) {

        }
        throw error
    })

}

async function hardlock(path) {

   console.log("This will reset secure_debug and dm_verity. Make sure you are in stock state or use butter to reflash if not. Type 'yes' to confirm?")
    return confirm()
    .then(() => {
        return identifyDevice(path)
        /*.then(() => {
            console.log("sending flash command for first slot")
            return shell(`
            umount /proc/cmdline || true
            update_engine --update_package=/cache/ota.zip
            reboot`)
        })
        .then(() => {
            console.log("waiting 2 minutes (30 seconds spare on just flash v2 goggles) for the flash to complete")
            return sleep(120000)
        })
        .then(() => { 
            port = new SerialPort({path: portPath, baudRate}) 
        })
        .then(() => {
            console.log("sending flash command for second slot")
            return shell(`
            umount /proc/cmdline || true
            update_engine --update_package=/cache/ota.zip
            reboot`)
        })
        .then(() => {
            console.log("waiting 2 minutes (30 seconds spare on just flash v2 goggles) for the flash to complete")
            return sleep(120000)
        })
        .then(() => { 
            port = new SerialPort({path: portPath, baudRate}) 
        })*/
        .then(patch)
        .then(()=> {
            const config = configs[device].debug
            config.data = Buffer.from("00000E00AF5C5F2800295F2FAF4849444A490000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF0000000000000000000000880AEE0E01D4E85374710961DECE84176BF1F91800000000000000000000000000000000000000000000000000000000", "hex")
            /*
                if(result.data[6] === 0x0e) {
                    offset = 1
                }
                //newer devices are et 5
                else if(result.data[5] === 0x0e) {
                    offset = 0
                }
            */
            //config.data = Uint8Array.from(Buffer.from("00000E00AF5C5F2800295F2FAF4849444A490000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF0000000000000000000000880AEE0E01D4E85374710961DECE84176BF1F91800000000000000000000000000000000000000000000000000000000", "hex"))
            return talk(port, config,  false)
            .then((result) => {
                console.log(result)
                port.close()
                console.log("hardlock should be done, power cycle your device")
                console.log("you can use 'shell reboot' and verify nothing happens")
                console.log("you should get:")
                console.log("harry, i'm sorry, you're not a wizard")
                process.exit(0)
            })
        })
        .catch((error)=> {
            console.log(error)
            process.exit(1)
        })
    })

}


function makeShellPayload(script) {
    //console.log("executing", script)
    script = ";"+script
    const scriptBuf = Buffer.from(script, "utf8")
    const lenBuf = Buffer.allocUnsafe(2)
    lenBuf.writeUInt16LE(scriptBuf.length)

    return Buffer.concat([
        Buffer.from("746573745f6c65645f666f725f70657263657074696f6e2e73680000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001a0000000b00000088130000", "hex"),
        lenBuf,
        scriptBuf]
    )
}


module.exports.unlock = unlock
module.exports.hardlock = hardlock
module.exports.lock = lock
module.exports.doShell = doShell
module.exports.doReboot = doReboot